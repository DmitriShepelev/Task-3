using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static Task_3.PortController;

namespace Task_3
{
    public class Station
    {
        private static readonly List<Port> ListPorts;
        private static readonly int TotalNumberOfPorts = Convert.ToInt32
            (ConfigurationManager.AppSettings.Get("totalNumberOfPorts"));

        static Station()
        {
            ListPorts = new List<Port>(TotalNumberOfPorts);
            SetListPorts();
        }

        public static Port GetFreePort => ListPorts.FirstOrDefault(x => x.State == PortState.Free);

        //private ICollection<CallEventArgs> CallsInInitializationState = new List<CallEventArgs>();

        public event EventHandler<CallEventArgs> CallRecordCreate;
        public void OnPhoneOutgoingCall(object sender, CallEventArgs args)
        {
            args.CallState = CallState.Initiation;
            Console.WriteLine($"Станция:Телефон пытается дозвонится по номеру {args.TargetPhoneNumber}");
            // нужен контроллер портов "определить в каком состоянии находится процесс инициации звонка"
            // телефоны станции не нужны, а вот порты - нужны, по портам будет выполнятся процесс поиска
            // например словарик - соответсвие порта телефонному номеру ??? по модели событий - не получится. нужен объект контроллера портов, внутри которого можно спрятать все необходимое
            // соответствия портов можно забрать до того как станция запустится, тогда на однин вид сущностей станция будет знать меньше (не нужны телефоны)

            GetPort(args.TargetPhoneNumber)?.OnIncomingCall(sender, args);
        }




        private static void SetListPorts()
        {
            for (int i = 0; i < ListPorts.Capacity; i++)
            {
                ListPorts.Add(new Port());
            }
        }
    }
}
//на станции несколько контейнеров 1. те звонки, которые в состоянии инициализации (соединение еще не произошло): либо один звонит другому, либо ожидает от него ответа (срабатывает на станции на первой стадии)
//далее можно модифицировать инф объект (добавить еще каких-нибудь состояний) и вернувшись опять на станцию можем н.п. перевести звонок в состояние дозвона (телефон второго непрерывно звонит)
// далее соединение может либо произойти, либо нет. Если да, то переводим объект из первого списка во второй - звонки которые сейчас текут. Но независимо от результата дозвона, должно происходить событие, которое можно назвать CallRecordCreate (это для биллинговой системы), общение с бил сис только через это событие (инжектировать ее в станцию не надо!)


// в бил сис должен быть обработчик события (OnCallRecordCreated()). Делаем прообраз БД, но на коллекциях. Внутри может быть коллекция объектов вида "Договор", коллекция оъектов вида "Информация о совершенном звонке", можно инжентировать зависимость на объект типа "Тарифный план"
// (желательно хорошо продумать, выделить Интерфейс - их у компании может быть несколько; выделить общий механизм расчета и заложить в бил сис для конечного итога расчетов по каждому абоненту исходя из общего механизма. т.е. - заложить ТП, список звонков и эта штуковина через "что-то такое общее" должна расчитать нам итоговую сумму; должна быть возможность смены тарифного плана).
// Модель данных сразу стройте как реляционную, т.е. соответствия вида первичный\внешний ключ не через ссылки на объекты, а через идентификаторы каких-то ссущностей. МиниБД, но только на коллекциях. подумать - карта соответствия между тел-ми и портами (номера тел-в - только в биллинговой системе). создать объекты портов и заматчить их на какие-то телефоны и в контроллере предусмотреть возможность смены порта для определенного телефона. 

// Отдельно стоят этап создания объектов. Отдельно - этап привязки. привязки могут быть как изначальными, так и строится "на ходу"(н.п. - назначили телефону порт, нужно что-то убрать, что-то привязать). И уже потом  - сценарий испольнения. Accept и Reject - это костыль, но костыль необходимый, что-бы не реализовывать в виде системы реального времени.